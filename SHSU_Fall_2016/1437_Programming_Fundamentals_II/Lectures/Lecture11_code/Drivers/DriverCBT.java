import java.util.Iterator;import TreePackage.*;import java.io.*;/**    A driver that demonstrates the class CloneableBinaryTree.      @author Frank M. Carrano   @author Timothy M. Henry   @version 4.0*/public class DriverCBT{	public static void main(String[] args)	{	   CloneableBinaryTree<String> aTree = new CloneableBinaryTree<>();		createTree(aTree);		showTreeStats(aTree, "A", 4, 8);		testLevelOrder(aTree, "A B C D E F G H");		testPreorder(aTree,   "A B D H E C F G");      testInorder(aTree,    "D H B E A F C G");		testPostorder(aTree,  "H D E B F G C A");		System.out.println("===================");      		System.out.println("======CLONE========");      @SuppressWarnings("unchecked")      CloneableBinaryTree<String> copyTree = (CloneableBinaryTree<String>)aTree.clone();		showTreeStats(copyTree, "A", 4, 8);		testLevelOrder(copyTree, "A B C D E F G H");		testPreorder(copyTree,   "A B D H E C F G");      testInorder(copyTree,    "D H B E A F C G");		testPostorder(copyTree,  "H D E B F G C A");      		System.out.println("======CHANGE THE ROOT OF THE ORIGINAL TREE========");		aTree.setRootData("Z");		showTreeStats(aTree, "Z", 4, 8);		testLevelOrder(aTree, "Z B C D E F G H");		testPreorder(aTree,   "Z B D H E C F G");      testInorder(aTree,    "D H B E Z F C G");		testPostorder(aTree,  "H D E B F G C Z");      		System.out.println("======CLONE========");		showTreeStats(copyTree, "A", 4, 8);		testLevelOrder(copyTree, "A B C D E F G H");		testPreorder(copyTree,   "A B D H E C F G");      testInorder(copyTree,    "D H B E A F C G");		testPostorder(copyTree,  "H D E B F G C A");      		System.out.println("======CHANGE THE ROOT OF THE CLONE========");      copyTree.setRootData("Y");		showTreeStats(copyTree, "Y", 4, 8);		testLevelOrder(copyTree, "Y B C D E F G H");		testPreorder(copyTree,   "Y B D H E C F G");      testInorder(copyTree,    "D H B E Y F C G");		testPostorder(copyTree,  "H D E B F G C Y");		System.out.println("======ORIGINAL TREE========");		showTreeStats(aTree, "Z", 4, 8);		testLevelOrder(aTree, "Z B C D E F G H");		testPreorder(aTree,   "Z B D H E C F G");      testInorder(aTree,    "D H B E Z F C G");		testPostorder(aTree,  "H D E B F G C Z");      		System.out.println("Done.");	}  // end main	public static void createTree(CloneableBinaryTree<String> tree)	{  //  D has H as right child   		// Leaves		CloneableBinaryTree<String> eTree = new CloneableBinaryTree<>("E");		CloneableBinaryTree<String> fTree = new CloneableBinaryTree<>("F");		CloneableBinaryTree<String> gTree = new CloneableBinaryTree<>("G");		CloneableBinaryTree<String> hTree = new CloneableBinaryTree<>("H");		// Subtrees:		CloneableBinaryTree<String> dTree = new CloneableBinaryTree<>("D", null, hTree);		CloneableBinaryTree<String> bTree = new CloneableBinaryTree<>("B", dTree, eTree);		CloneableBinaryTree<String> cTree = new CloneableBinaryTree<>("C", fTree, gTree);		tree.setTree("A", bTree, cTree);		      System.out.println("\nA tree:\n");      System.out.println("     A      ");      System.out.println("   /   \\   ");      System.out.println("  B     C   ");      System.out.println(" / \\   / \\");      System.out.println("D   E  F  G ");      System.out.println(" \\         ");      System.out.println("  H         ");      System.out.println();	} // end createTree	public static void showTreeStats(CloneableBinaryTree<String> tree, String root, int height, int numberOfNodes)	{		if (tree.isEmpty())			System.out.println("The tree is empty");		else			System.out.println("The tree is not empty");				System.out.println("Root of tree is " + tree.getRootData() + "; s/b " + root);				System.out.println("Height of tree is " + tree.getHeight() + "; s/b " + height);		System.out.println("# nodes in tree is " + tree.getNumberOfNodes() + "; s/b " + numberOfNodes);	} // end showTreeStats 	public static void testLevelOrder(CloneableBinaryTree<String> tree, String answer)	{		System.out.println("\nLevel order:");		System.out.println(answer + "  Expected");	 	Iterator<String> levelOrder = tree.getLevelOrderIterator(); 				while (levelOrder.hasNext())		{				System.out.print(levelOrder.next() + " ");		} // end while				System.out.println(" Actual\n---------------");	} // end testLevelOrder 	public static void testPreorder(CloneableBinaryTree<String> tree, String answer)	{		System.out.println("\nPreorder:");		System.out.println(answer + "  Expected");	 	Iterator<String> preorder = tree.getPreorderIterator(); 				while (preorder.hasNext())		{				System.out.print(preorder.next() + " ");		} // end while				System.out.println(" Actual\n---------------");	} // end testPreorder 	public static void testInorder(CloneableBinaryTree<String> tree, String answer)	{		System.out.println("\nInorder:");		System.out.println(answer + "  Expected");	 	Iterator<String> inorder = tree.getInorderIterator(); 				while (inorder.hasNext())		{				System.out.print(inorder.next() + " ");		} // end while				System.out.println(" Actual\n---------------");	} // end testInorder 	public static void testPostorder(CloneableBinaryTree<String> tree, String answer)	{		System.out.println("\nPostOrder:");		System.out.println(answer + "  Expected");	 	Iterator<String> postorder = tree.getPostorderIterator(); 				while (postorder.hasNext())		{				System.out.print(postorder.next() + " ");		} // end while				System.out.println(" Actual\n---------------");	} // end testPostorder }  // end DriverCBT/*  A tree:  A /   \ B     C / \   / \ D   E  F  G \ H  The tree is not empty Root of tree is A; s/b A Height of tree is 4; s/b 4 # nodes in tree is 8; s/b 8  Level order: A B C D E F G H  Expected A B C D E F G H  Actual ---------------  Preorder: A B D H E C F G  Expected A B D H E C F G  Actual ---------------  Inorder: D H B E A F C G  Expected D H B E A F C G  Actual ---------------  PostOrder: H D E B F G C A  Expected H D E B F G C A  Actual --------------- =================== ======CLONE======== The tree is not empty Root of tree is A; s/b A Height of tree is 4; s/b 4 # nodes in tree is 8; s/b 8  Level order: A B C D E F G H  Expected A B C D E F G H  Actual ---------------  Preorder: A B D H E C F G  Expected A B D H E C F G  Actual ---------------  Inorder: D H B E A F C G  Expected D H B E A F C G  Actual ---------------  PostOrder: H D E B F G C A  Expected H D E B F G C A  Actual --------------- ======CHANGE THE ROOT OF THE ORIGINAL TREE======== The tree is not empty Root of tree is Z; s/b Z Height of tree is 4; s/b 4 # nodes in tree is 8; s/b 8  Level order: Z B C D E F G H  Expected Z B C D E F G H  Actual ---------------  Preorder: Z B D H E C F G  Expected Z B D H E C F G  Actual ---------------  Inorder: D H B E Z F C G  Expected D H B E Z F C G  Actual ---------------  PostOrder: H D E B F G C Z  Expected H D E B F G C Z  Actual --------------- ======CLONE======== The tree is not empty Root of tree is A; s/b A Height of tree is 4; s/b 4 # nodes in tree is 8; s/b 8  Level order: A B C D E F G H  Expected A B C D E F G H  Actual ---------------  Preorder: A B D H E C F G  Expected A B D H E C F G  Actual ---------------  Inorder: D H B E A F C G  Expected D H B E A F C G  Actual ---------------  PostOrder: H D E B F G C A  Expected H D E B F G C A  Actual --------------- ======CHANGE THE ROOT OF THE CLONE======== The tree is not empty Root of tree is Y; s/b Y Height of tree is 4; s/b 4 # nodes in tree is 8; s/b 8  Level order: Y B C D E F G H  Expected Y B C D E F G H  Actual ---------------  Preorder: Y B D H E C F G  Expected Y B D H E C F G  Actual ---------------  Inorder: D H B E Y F C G  Expected D H B E Y F C G  Actual ---------------  PostOrder: H D E B F G C Y  Expected H D E B F G C Y  Actual --------------- ======ORIGINAL TREE======== The tree is not empty Root of tree is Z; s/b Z Height of tree is 4; s/b 4 # nodes in tree is 8; s/b 8  Level order: Z B C D E F G H  Expected Z B C D E F G H  Actual ---------------  Preorder: Z B D H E C F G  Expected Z B D H E C F G  Actual ---------------  Inorder: D H B E Z F C G  Expected D H B E Z F C G  Actual ---------------  PostOrder: H D E B F G C Z  Expected H D E B F G C Z  Actual --------------- Done. */